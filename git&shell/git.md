## 版本控制系统（Version Control Systems）
> 这是一种记录一个或若干文件内容变化，以便将来查阅特定版本修改情况的软件。
这个软件可以自动帮我们备份文件的每一次更改，并且可以非常方便的恢复到任意的备份（版本）状态。
使用版本控制查看一个文件的变动历史，类似与下面的样子:</br>

| 版本 | 用户 | 记录 | 备注 | 日期 | 
|---|---|
| 1 | 我 | 删除信息 | 删除今日消费记录 | 1/12 08:00
| 2 | 我 | 填写信息 | 填写今日收入 | 2/14 14:30
| 3 | 女友 | 填写信息 | 填写旅游计划 | 5/17 18:10

</br>此我们就结束了手动管理多个版本的史前时代。

### 版本控制系统的分类
> 实现版本控制的软件有很多种类，大致可以分为本地版本控制系统、集中式版本控制系统、分布式版本控制系统。

#### 本地式版本控制系统 
> 借助软件我们可以记录下文件的每一次修改，文件被修改后，
我们通过版本控制系统（软件）便可以非常方便的恢复到任意版本。
这种类型的版本控制系统，功能比较单一，比如很难实现多人协同开发，
有些文件编辑工具自身会带有本地版本控制系统，比如WebStorm中的Local History。
</br>![本地式](./local_version.png)

#### 集中式版本控制系统
> 实际开发环境，一个项目通常是由多人协作共同完成的，
如何让在不同终端上的开发者协同工作成了亟待解决的问题。集中式版本控制系统便应运而生了。
它通过单一的集中管理的服务器，保存所有文件的修订版本，
协同工作的开发者都通过客户端连到这台服务器，取出最新的文件或者提交更新。其代表为SVN。
集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，
可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊，
另外集中管理的服务器一旦出现故障，将会存在数据（版本）丢失的风险。
</br>![集中式](./img/git/central_version.png)

#### 分布式版本控制系统
> 分布式版本控制系统，则不需要中央服务器，每个协同开发者都拥有一个完整的版本库，
这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。

在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，
因为可能你们俩不在一个局域网内，两台电脑互相访问不了，
也可能今天你的同事病了，他的电脑压根没有开机。
因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，
但这个服务器的作用仅仅是用来方便“交换”大家的修改，
没有它大家也一样干活，只是交换修改不方便而已。
</br>![分布式](./img/git/distributed_version.png)

#### 集中式和分布式比较
和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，
因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。
而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。

## git
> git是目前世界上最流行的分布式版本控制系统。

### git的诞生
> 很多人都知道，Linus在1991年创建了开源的Linux，
从此，Linux系统不断发展，已经成为最大的服务器系统软件了。
  
Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，
这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？
  
事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，
然后由Linus本人通过手工方式合并代码！
  
当时已经存在一些版本控制系统了，比如CVS和SVN，但是Linus坚定地反对使用它们，
这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。
有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。
  
不过，到了2002年，Linux系统已经发展了十年了，
代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，
于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，
授权Linux社区免费使用这个版本控制系统。

后来，因为总总原因BitMover公司收回了Linux社区的免费使用权。
Linus心里不爽就花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！
一个月之内，Linux系统的源码已经由Git管理了！

### git的4种文件状态
git在管理我们文件的时候，给文件定义了4种状态，
- 未追踪（untracked）
- 已暂存（staged）
- 已修改（modified）
- 已提交（committed）

### git的3种工作区
4种文件状态由此引入了git项目的3个工作区域。
- 工作目录: 即我们编写代码的工作目录。
- 暂存区域：工作目录的临时备份。
- 版本仓库：所有文件版本的永久备份。

### git基本工作流
1. 在工作目录中增加编辑文件。
2. 暂存文件，将文件的快照放入暂存区域。
3. 提交文件，把暂存区域的文件快照永久性存储到git仓库目录。

## git安装与配置

### 安装
- [git官网](你的链接地址)自行下载安装
- 安装完毕后在桌面鼠标右键，查看列表中是否多了Git GUI Here/Git Bash Here两项
- 点击Git Bash Here，会打开bash命令窗口，输入git --version会打印git安装信息。

### 配置全局用户名与邮箱
- 配置用户的意义在于记录开发者信息，以便在版本控制记录开发者的操作行为，
如某某某于2016-08-24解决了一个bug。--global代表全局配置，以后创建的所有仓库都默认使用该配置
    + git config --global user.name 自己的名字
    + git config --global user.email 自己的邮箱
- 查看配置信息
    + git config --list
  
## git基本使用

###### 3、初始化仓库
- 我们如果想要利用git进行版本控制，需要将现有项目初始化为一个仓库，
或者将一个已有的使用git进行版本控制的仓库克隆到本地。
    + git init
- 查看当前项目目录是否创建了一个名为.git的隐藏目录，
这个目录包含了暂存区和仓库两个区域，有了这个隐藏目录就可以使用git来管理项目了。
    + ls -al

###### 4、查看文件状态
- 初始化仓库后便可以进行开发了，进入到刚刚创建好并初始为仓库的目录，
添加我们开发需要的文件，然后查看文件的状态（未追踪untracked）。
    + mkdir css js
    + echo 页面结构 >> index.html
    + echo 样式编写 >> css/index.css
    + git status

###### 5、添加文件到暂存区
- 经过一定的编写，要对文件进行版本管理，需要先把新建的文件添加到暂存区。
然后查看文件状态，放到暂存区的文件被标记成了绿色，等待提交。
注：颜色是工具给添加的，目的是增加可读性并不是git统一的。
    + git add 文件1 文件2 ..
    + git status
- 文件太多可以使用*或者-A选项代表所有
    + git add [* | -A]

###### 6、撤销更改
- 继续我们的开发，然后查看仓库状态，
修改的文件被标记为了红色，说明index.html被再次修改了。
    + echo 页面结构2 >> index.html
    + git status
- 提交修改，然后继续开发，假设新编写的代码有问题，
想要回到之前状态，将暂存的文件还原到工作区。
    + echo 页面结构3 >> index.html
    + cat index.html
    + git checkout [--] index.html
    + cat index.html
    
###### 7、修改比较
- 继续我们的开发，开发一段时间后，想和上一次暂存的文件进行比较，
确认一下具体都对哪些地方做了修改，确认修改无误后添加到暂存区。
    + echo 新版页面结构3 >> index.html
    + git diff index.html
    + git add .
    
###### 8、提交文件
- 经过一个相对较长阶段开发或者一个功能开发完成了，
就可以提交到本地仓库了，永久保存了。
这时被标记成绿色的暂存区文件，全部提交到本地仓库存储。
    + git status
    + git commit -m '备注信息'
    + git status

###### 9、查看提交历史
- 反反复复开发了很多的功能了，查看一下提交的版本历史。
默认查看全部，如果比较多可以像vi快捷键那样上下翻页，q退出。
也可以任意指定查看的数量以及格式化输出。
    + git log [--oneline] [数量]

###### 10、新一轮开发
- 创建文件、修改文件
- 添加到暂存区
- 提交版本
- 查看提交历史

###### 11、版本回退
- 开发中需要可能随时发生变化，假设刚刚开发完毕的功能要舍弃，
重新开发新的功能，我们可以恢复到之前某一次的提交，
在那个基础上进行新的需求开发，然后查看版本历史，恢复了之前的某个时期。
    + git log
    + git reset --hard 版本ID
    + git log

###### 12、版本变化历史
- 也许有一天你想查阅之前所有的历史版本变化，
或者寻找某个已丢失的版本，该命令会对你有所帮助。
    + git reflog

### 分支
> 分支就像是对一个目录进行多次拷贝，一次拷贝看作是一个分支，
在不同的分支中进行不同的功能开发与修改，这样在不同功能开发时避免杂乱，
最终可以把多个子分支再合并到最初的主目录，这样也更符合团队开发流程。

在我们的现实开发中，需求往往是五花八门的，同时开发多个需求的情况十分常见。
有时候突然冒出一个需求，可能要优先完成，但是我们已经正在专注开发一个功能，
要终止当前开发，转入新需求开发，分支就派上了用场。
分支可以让我们并行开发多个不同的功能，在开发时互干涉与影响，
直到开发完毕后，再一次性合并到原来的分支上。
分支在团队合作中应用甚广，即方便安全，又不影响别人工作。

###### 1、创建分支
- 当我们在初始化仓库的时候（实际上是产生第1次提交时），
Git会默认帮我们创建一个master的分支，所以之前我们的操作都是在该分支下完成的。
该分支通常被作为项目的主干使用，基于它我们可以创建各种子孙分支，
子分支会继承父分支当前的版本记录，现在我们就创建一个子分支，进行我们新的开发任务。
    + git branch 分支名称

###### 2、切换分支
- 刚才只是创建了一个新的分支，我们还需要切换到该分支。
    + git checkout 分支名称

###### 3、创建新分支
- 像之前在master分支那样，使用各种命令对文件进行操作，
然后出现一个比较急的新需求需要我们马上切入，
可以对当前分支的文件进行提交，然后创建新的分支进行开发。
    + echo 'console.log('xx分支未完成')' >> js/main.js
    + git commit -am '切入紧急需要开发，暂存提交'
    + git checkout master
    + git branch 新分支名称
    
###### 4、分支合并
- 紧急任务开发完毕后，进行提交。
测试无误后，把该功能的代码合并到master主分支上。
查看文件是否合并成功，然后查看版本历史里多了之前分支上的提交记录。
    + echo 'console.log('紧急新需求')' >> js/main.js
    + git commit -am '完成xx紧急任务'
    + git checkout master
    + git merge 新分支名称
    + cat js/main.js
    + git log --oneline
     
###### 5、删除分支
- 子分支合并到父分支后，已经没有用处了，可以删除掉。
然后可以切换到都其他分支，或者创建新的分支继续开发。
    + git branch -d 新分支名称
    + git branch
    
###### 6、冲突解决
- 到目前为止，我们基于master主分支创建了两个分支，
其中一个分支已经开发完毕，并且对一些文件进行了修改，
现在进入到另一个分支进行开发，可能也会对相同的文件进行修改。
    + git checkout 分支名称 
    + echo 'console.log('完成')' >> js/main.js
    + git commit -am 'xx分支继续完成未完成任务'
- 这样，将来master在并入该分支时，某些文件就会不同修改造成的冲突。
我们需要手动对存在冲突的文件进行编辑，然后重新添加与提交。
查看版本历史，分支的版本已经融入，此时该分支也可以被删除了。
    + git checkout master
    + git merge 分支名称
    + vi js/main.js
    + git commit -am '解决xx分支冲突'
    + git log --oneline
    + git branch -d 分支名称
    
### 远程仓库
通过上面学习我们可以很好的管理本地版本控制了，
可是如果我们下班回到家里突然来了灵感觉得有部分代码可以优化，
如果能接着公司电脑上的代码继续写该有多好呀！
另一种情形，假设项目比较大，不同的功能模块由不同的开发人员完成，
不同模块儿之间又难免会依赖关系，这时如果我们的代码互相合并（融合）该有多好呀！
所有模块开发完毕后，需要整合到一起，要能做到准确无误该有多好呀！
借助一个远程仓库，大家可以共享代码、历史版本等数据，便可以解决以上遇到的所有问题。

###### 1、创建远程仓库
- Git要求共享仓库是一个以.git结尾的目录，创建该目录。
然后进入目录运行初始化命令，注意--bare参数。
该方式创建的仓库称为裸仓库，即没有工作区，裸露暂存区与版本区的仓库。
    + mkdir remote_dir.git
    + cd remote_dir.git
    + git init --bare
    + ls -l
    
###### 2、基于远程仓库创建本地仓库
- 新创建一个目录，然后进入该目录，基于远程仓库创建本地仓库。
clone操作与init操作一样，一个仓库只需运行一次即可。
    + git clone ../remote_dir.git .

###### 3、本地仓库向远程仓库推送内容
- 在本地仓库进行文件添加与修改，并提交到版本库。
然后把本地内容推送到远程仓库进行备份与共享。
    + echo '项目创建' >> index.html
    + git add index.html
    + git commit -m '项目创建'
    + git push ../remote_dir.git master
    
###### 4、创建第二个本地仓库
- 创建第二个同级别的目录，模拟另外一个开发者，然后基于远程仓库创建本地仓库。
创建好后，查看仓库内容与历史版本。
    + git clone ../remote_dir.git master
    + git log
    + ls
    
###### 5、仓库2推送内容到远程
- 第二个仓库进行自己的开发工作，然后提交到远程仓库。
    + mkdir css
    + echo 'body{padding:0;margin:0;}' >> css/main.css
    + git add css/main.css
    + git commit -m '初始化样式'
    + git push ../remote_dir.git master
    
###### 6、仓库1获取远程最新内容
- 切换到第二个仓库，获取最新的远程仓库内容，查看文件内容与历史版本。
奇迹似乎发生了，我们轻松的将仓库2里的内容，通过远程仓库共享给了仓库1。
    + git pull ../remote_dir.git master
    + ls -l
    + git log

### gitHub
刚才我们只是在本地模拟了远程仓库的能力。但真正开发时我们是不可能把远程仓库建在我们本地的。
如果我们熟悉服务器的话，完全可以将上述的步骤在我们的远程服务器上进行操作，
然后再做一些登录权限的设置，就可非常完美的搭建一个git远程仓库服务器了。
不过已经有第三方机构开发出了Web版的仓库管理程序，通过Web界面形式管理仓库。
gitHub就扮演了这样一个角色借助，它的名气大家可以自行搜索查阅，在gitHub我们可以免费并且很容易的创建远程仓库。
同时GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。

###### 1、账号注册
- [gitHub](https://github.com/) 自行注册。

###### 2、创建远程仓库
- 点击头像左边的“+”号，选择New repository
    + <br/>![资料填写](./img/github/info.png)
    + <br/>![成功界面](./img/github/success.png)

###### 3、本地仓库关联
- 进入本地一个已经初始化过并存在历史版本的仓库。
然后给远程仓库起个origin别名，成功后把本地master分支代码推送到远程仓库的master分支上。
推送时添加-u参数，在下次推送文件到时远程时，默认就推送到了master分支。
    + git remote add origin github仓库地址
    + git push -u origin master
- 如果本地使用一个新目录，那clone就可以了。
当我们通过clone创建本地仓库时，git会自动帮我们添加origin到对应的仓库地址。
    + git clone git@github.com:xxx.git 目录

###### 4、本地推送内容到远程
- 本地开发一个功能，推送到远程时，一般会先拉取一下远程最新内容，没有问题后再推送。
    + git pull origin(远程地址别名) master(远程分支名)
    + git push origin(远程地址别名)

###### 5、模拟另一个人共享你的代码
- 本地新建一个空目录，然后进入该目录，clone远程仓库。
验证当前仓库是否通过远程仓库获取到了另一个本地仓库的内容。
    + git clone git@github.com:xxx.git 目录
    + git log --oneline
    + ls -l
    
###### 6、两个本地仓库借用远程仓库协作
- 在本地任意一个仓库进行代码编写和提交，然后push到远程，
然后另一个本地仓库尝试pull获取。

### SSH
> SSH为建立在应用层基础上的安全协议，
SSH是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。
利用SSH协议可以有效防止远程管理过程中的信息泄露问题。
基于SSH协议存在多种实现，既有商业实现，也有开源实现，git默认支持SSH协议的用户认证与数据传送。

###### SSH数据传输时的加密方式
- 常见有两种加密技术，分别是对称性加密和非对称性加密，SSH属于后者。
- 对称加密算法在加密和解密时使用的是同一个密钥；
- 而非对称加密算法需要两个密钥来进行加密和解密，
- 这两个秘钥分别是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。
- 使用公钥加密的数据，只有私钥可以解密；使用私钥加密的数据，只有公钥可以解密。

###### 配置github公钥
- 运行命令，一顿回车，最终会在当前用户目录下生成一个.ssh的文件夹；
进入会看到里面含有两个文件，id_rsa存储密钥，id_rsa.pub存储公钥。
    + ssh-keygen -t rsa
- 进入gitHub的settings界面
    + <br/>![setting入口](./img/github/settings.png)
- 切到SSH keys的选项，创建ssh key，并把id_rsa.pub里存储的公钥复制到文本框，
书写一个标题，然后添加保存。
    + <br/>![ssh key](./img/github/ssh_key.png)
- 使用ssh连接github，查看是否出现你在github上注册的用户名和successful的提示。
如果出现，证明配置成功，尝试使用ssh的仓库地址进行clone，然后免密推送。
    + ssh git@github.com
    
###### github个人主页
- 新建一个仓库，仓库名字：用户名.github.io
注：一个用户只能拥有一个自己的网站。
- 往该github仓库中添加代码，注意最好给这些目录中添加一个index.html文件。
- 直接使用仓库的名字作为网站的地址来访问。

### 常用命令汇总
- git config配置本地仓库
    + 常用git config --global user.name、git config --global user.email
    + git config --list查看配置详情
- git init 初始一个仓库
    + 添加--bare可以初始化一个共享（裸）仓库
- git status 可以查看当前仓库的状态
- git add “文件” 将工作区中的文件添加到暂存区中
    + 其中file可是一个单独的文件，也可以是一个目录、“*”、-A
- git commit -m '备注信息' 将暂存区的文件，提交到本地仓库
- git log 可以查看本地仓库的提交历史
- git reflog 可以查看版本的变化历史
- git branch 查看分支
    + git branch “分支名称” 创建一个新的分支
    + git branch -d “分支名称” 删除分支
- git checkout “分支名称” 切换分支
    + git checkout -b deeveloper 他健并切到developer分支
- git merge “分支名称” 合并分支
- git clone “仓库地址” 获取已有仓库的副本
- git push origin “本地分支名称:远程分支名称” 将本地分支推送至远程仓库
    + git push origin hotfix（通常的写法）相当于 git push origin hotfix:hotfix
    + git push origin hotfix:newfeature
- git remote 可以查看已添加的远程主机
    + git remote add “主机名称” “远程仓库地址” 添加远程主机，即给远程主机起个别名
    + git remote show “主机名称” 可以查看远程主机的信息

### 其他
熟悉掌握以上操作，基本上是可以满足日常开的需要的，
但是在解决一些特殊问题时，就又需要我们能够掌握更多的命令。

###### gitLab了解
- 我们发现通过gitHub管理仓库实在是太方便了，可是只能免费使用公开仓库，
自已公司的代码当然不能公开了，可是私有仓库又是需要交“保护费”的，
无耐国人还是比较喜欢免费的，网络界总是有很多雷峰的，比如gitLab!!!
- gitLab也是一个可以通过Web界面管理仓库的网站程序，
我们可以把它架设到公司自已的服务器上，实现仓库私有化，
这也是大部分公司通常采用的方法，其使用方法与gitHub十分相似。

###### 文件忽略
在项目根目录下创建一个.gitignore文件，可以将不希望提交的罗列在这个文件里。