# 衍生线性表
在最基本的线性表结构基础上进行改造或创新，衍生出来的线性表结构，可以解决某类问题，但数据结构会跟着复杂起来

## 静态链表
- 静态链表主要是用数组模拟动态链表结构的存储空间分配，需要的时候申请，不需要的时候释放

#### 结构特点
- 内部通过`数组`存储数据元素
- 数据元素由`游标`和`数据`共同构成，其中`第一个`和`最后一个`元素`只存储游标`
- 第一个元素游标为`备用链条`的起始下标，最后一个游标为`已有数据`的起始下标
    + 备用链条：用游标链成的`未被使用`过的及已`被删除`的数组元素`链条`
- 已有数据元素的`最后一个`游标`固定为0`，代表没有下一个数据，其他元素游标均为`下一个数据`的下标

###### 空表图例
```javascript
[ 
  // 指向第一个备用元素
  {lastIndex: 1}, 

  // 指向下一个无数据元素
  {nextIndex: 2, data: undefined}, 
  {nextIndex: 3, data: undefined},
  {nextIndex: 4, data: undefined},
  {nextIndex: 5, data: null},
  {nextIndex: 6, data: null},
  ...,

  // 指向第一个数据元素
  {firstIndex: 1}
]
```

###### 链表图例
```javascript
[ 
  // 指向第一个备用元素
  {lastIndex: 4}, 

  // 指向下一个数据元素，最后一个数据元素指向0
  {nextIndex: 2, data: a1}, 
  {nextIndex: 3, data: a2},
  {nextIndex: 0, data: a3},

  // 指向下一个无数据元素
  {nextIndex: 5, data: null},
  {nextIndex: 6, data: null},
  ...,

  // 指向第一个数据元素
  {firstIndex: 1}
]
```

#### 性能
- 和链式结构性能一致，因为本身就是链式结构，只不过使用数组模拟实现的

#### 优点
- 相比顺序结构，只需`修改游标`，无需`移动元素`
- 相比顺序结构，`批量`插入或删除是，只要第一次`O(n)`比较消耗性能，后续都是`O(1)`

#### 缺点
- 相比顺序结构，需要为元素间的`逻辑关系`增加额外的`存储空间`使用
- 相比顺序结构，`查找`时需要遍历查找，效率`较慢`，失去了随机存取的特性
- 相比顺序结构，仍然存在连续存储单元带来的`空间浪费`与`碎片`问题

#### 结论
- `静态链表`是为了给`没有指针`功能编程语言设计的一种实现`单链表`功能的方法
- 如果`有指针`功能实现的`单链表`，在`空间`使用上更灵活，那么就不会使用静态链表了

---

## 循环链表

#### 结构特点
- 将单链表中的`终端节点`的指针由空指针改为`指向头节点`，使整个单链表形式一个`环`
- 这种`头尾相接`的单链表称为`单循环链表`，简称`循环链表`
- 循环链表没有头指针，而是有一个指向最后节点的`后指针`
- 循环链表找到`最后`一个节点的效率为`O(1)`，`第一`个节点也为`O(1)`

###### 空循环单链图例
```javascript
终端节点无数据{next: 自己} <= 后指针
```

###### 循环单链图例
```javascript
// 每个节点存储下一个节点指针
{data: a1, next: a2}
{data: a2, next: a3}
{ ... }
{data: an, next: 终端节点} 

// 终端节点无数据，存储第一个节点指针
{next: a1} <= 后指针
```

#### 性能
- 和单链表一样，只不过尾节点指针指向了头节点

#### 优点
- 除了单链表的有点外，循环链表查找最后一个节点的效率比较高，由O(n)提高到O(1)

#### 缺点
- 和单链表一样，查找其他元素比较慢，每个元素需要额外存储一个指针

---

## 双向链式结构

#### 结构特点
- 在单链表的基本上，每个元素`多了`一个指针域，指向前置元素
- `第一个`元素无前置为null，`最后一个`元素无后置为null

###### 空双向链图例
```javascript
头指针 => 头节点无数据{pre: null, next: null}
```

###### 非空双向链图例
```javascript
// 头节点无数据，存储第一个节点指针
头指针 => {pre: null, next: a1}

// 每个节点即存储下一个节点指针，又存储上一个节点指针
{pre: header, data: a1, next: a2}
{pre: a1, data: a2, next: a3}
{ ... }

// 最后一个节点没有下一个
{pre: an-1, data: an, next: null}
```

#### 性能
- 可以提高单链表的某些性能，以空间换时间
- 和单链表一样，查找效率为O(n)，好处时可以追溯前一个节点

#### 优点
- 插入和删除时，即可以从元素前面，也可以从元素后面进行操作

#### 缺点
- 每个元素需要额外存储`两个`指针，比单项链表还多一个

---

## 双向循环链式结构

#### 结构特点
- 在`双向链式结构`的基础上形成`环`
- `第一个`元素前置为`最后一个`元素，`最后一个`元素后置为`第一个`元素

###### 空双向循环链图例
```javascript
// 终端节点无数据
{pre: 自己, next: 自己} <= 后指针
```

###### 双向循环链表图例
```javascript
// 头节点无数据，上一个指向数据的最后，下一个指向数据的开始
头指针 => {pre: an, next: a1}

// 每个节点即存储下一个节点指针，又存储上一个节点指针
{pre: header, data: a1, next: a2}
{pre: a1, data: a2, next: a3}
{ ... }
{pre: an-1, an, next: header}
```

#### 性能
- 和双向链表一样，只不过`头尾互指`

#### 优点
- 除了双向链表的优点外，双向循环链表查找最后一个节点的效率高，由O(n)提高到O(1)
- 可以灵活选择`从前到后`，`从后到前`进行`查找`等操作

#### 缺点
- 和双向链表一样，每个元素需要额外存储`两个`指针
