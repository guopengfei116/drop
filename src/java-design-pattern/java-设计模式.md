# Java Design Pattern

设计模式是一套被反复使用，经过分类的，代码设计经验的总结。

## 分类

### **创建型模式**

| 1 | 2 | 3 | 4 | 5 |
| :-: | :-: | :-: | :-: | :-: |
| 单例模式 | 建造者模式 | 原型模式 | 工厂方法模式 | 抽象工厂模式 |

### **结构型模式**

| 1  | 2  | 3  | 4  | 5  | 6  | 7 |
| :-: | :-: | :-: | :-: | :-: | :-: | :-: |
| 代理模式 | 外观模式 | 桥接模式 | 组合模式 | 享元模式 | 适配器模式 | 装饰器模式 | 

### **行为型模式**

| 1  | 2  | 3  | 4  | 5  | 6  |
| :-: | :-: | :-: | :-: | :-: | :-: |
| 策略模式 | 命令模式 | 状态模式 | 观察者模式 | 访问者模式 | 中介者模式 |
| 责任链模式 | 备忘录模式 | 解释器模式 | 迭代子模式 | 模板方法模式 |

### **其他行为模式**

| 1 | 2 |
| :-: | :-: |
| 并发型模式 | 线程池模式 |

- - -

## 六大原则

六大原型的核心是开闭原则，即对扩展开放，对修改封闭，实现热插拔效果。<br />
简单点说就是解决问题的同时，还得保证程序的扩展性，易于维护和升级。

### **单一职责原则** - Single Responsibility Principle

每个类只负责解决一种事务，如果有新事务会导致类职责的变更或多元化，那么应该拆分它。

### **里氏替换原则** - Liskov Substitution Principle

任何基类可以出现的地方，子类一定可以出现，这是继承复用的基石。<br />
只要当衍生类可以替换基类，并不怕坏软件功能时，基类才能真正被复用，衍生类才能更好的发展新功能。<br />
里氏替换原则提倡子类尽量不要重写和重载父类方法。<br />
因为父类代表了定义好的结构，通过这个规范的接口于外界交互，子类不应该随便破坏它。

### **依赖倒转原则** - Dependence Inversion Principle

面向接口编程，依赖于抽象而不依赖于具体。<br />
写代码用到具体类时，不与具体类交互，而与具体类的上层接口交互。

### **接口隔离原则** - Interface Segregation Principle

每个接口不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。<br />
使用多个隔离的接口，比使用单个接口要好得多

### **最少知道原则** - Demeter Principle

一个类对自己依赖的类知道的越少越好，这样当被依赖的类变化时，才能最小的影响该类。<br />
被依赖的类无论多么复杂，都应该将完整的逻辑封装在方法内部，通过public暴露给外部调用

### **合成复用原则** - Composite Reuse Principle

尽量使用合成/聚合的方式，而不是使用继承。
