# 模块化

## 引言
- 有人说给他一块足够大的橡皮泥，便捏造整个世界
- 那么如果给你一块橡皮泥，让你捏造出下面的房子你觉得可不可行？
- 或许你会说有点难度，但如果给你换成积木，你是不是会觉得没问题呢！
![积木](img/jimu.png)

## 什么是模块化
- 模块就是一个个积木，每个模块都有自己专属的功能与定位
- 模块化就是把我们编写的js按业务逻辑，拆分成多个功能单一的js文件进行使用与维护
- 这就是模块化的开发理念，这种模式下编写的每一个文件都被认为是一个模块
- 说白了，就是写代码的时候不要把所有逻辑放到同一个文件，而是编写很多js模块，最后组装使用

## 模块化的必要性
- 现在前端应用相比以往越来越复杂，越来越像桌面应用程序，复杂度可想而知
- 像这样的项目一般需要多人协作开发，同时采用软件工程的方法来管理我们的应用逻辑
- js模块化编程变得迫在眉睫，我们需要开发出不同功能的模块，最后组装成为最终的应用程序
- 理想的情况是，我们只编写核心的业务逻辑模块，剩余功能则集成使用别人写好的模块

## 不同的模块化阵营与趋势

####AMD
    - 2~3年前在前端比较流行，使用较多的模块化规范
    + 缺点是http请求过多，不利于优化，且不好解决
    + 进两年随着前端新技术的发展使用逐渐减少

#### CommonJS
    - Node所采用的模块化范围，随着node的发展，出现了各种工具把CommonJS带入了前端
    + 比如browerify、webpack，他们使CommonJS规范编写的代码也开始适合在浏览器环境下运行
    + 这些工具会把多个js文件打包合并，目前应用比较流行。

#### ES6模块化
    - 未来趋势，但目前还没有浏览器支持该特性
    + 目前比较流行的方式是，先提前使用es6的模块化语法进行前端开发
    + 然后通过webpack工具转化为类似CommonJS规范的代码在浏览器运行

#### 小结
    - AMD是一种模块化开发规范，目前流行的三大模块化规范分别是：AMD、CommonJS、ES6
    + RequireJS实现了AMD规范，因为AMD规范是为了浏览器环境而制定的标准
    + NodeJS实现了CommonJS规范，CommonJS规范是为了非浏览器环境而指定的标准
    + 2015年发布的ES6模块化规范，从原生层面上赋予了javascript语言对模块化的支持

# RequireJS
requireJS是一个模块化开发类库，该类库只提供了两个功能，加载模块与定义模块

## require
- RequireJS提供了一个require全局方法用来加载模块，模块的.js后缀名不用书写
- require的作用就是通过函数的方式异步加载js，相比传统的script标签同步加载更快

```javascript
require(['src/js/a', 'src/js/b']);
```

## define

#### 问题
- 上面的代码a与b模块的下载与执行是异步的
- 如果b模块依赖a模块，那么可能会有问题

#### 解决
- RequireJS提供了define全局方法用来定义模块
- 使用define定义模块的好处是在js代码中声明模块依赖，有利于项目后期维护
- 同时define定义的模版不会产生任何全局变量

```javascript
define([], function() {
	var a = 10;
	return a;
});
```
```javascript
define(['a'], function(a) {
	var b = 20;
	console.log(a + b);
});
```
```javascript
require(['src/js/a', 'src/js/b']);
```

## data-main
- 在页面中引入requirejs的script标签，可以通过添加data-main属性配置一个入口模块
- requirejs库自身加载完毕后，会在第一时间加载该模块

```
<html lang="en">
<head>
</head>
<body>
	<script src="require.js" data-main="./src/js/main"></script>
</body>
</html>
```

## API小结与补充

#### require
- 作用：加载模块
- 语法：require([模块1, 模块2, 模块3, ...], function() {})
- 备注：第一个参数为加载的模块列表，第二个参数可选，为模块加载完毕后的回调。

#### define
- 作用：定义模块
- 语法：define([模块1, 模块2, 模块3, ...], function() {})
- 备注：第一个参数为模块的依赖列表，第二个参数为模块主体，通常是一个函数，实际上可以是任意数据类型。

#### require方法使用模块输出(即模块对外暴露的东西)

AMD模块
    - 如果模块主体是一个函数，那么函数的返回值即该模块的输出
    - 如果模块主体是其他数据类型，那么输出的就是数据本身

普通模块
    - 需要配置该模块中申明的全局变量，配置什么就输出什么
    - 如果不配置，什么都不输出，require会收到undefined值

## requireJS优点汇总

#### 模块依赖更清晰
- 编写一个大型项目，会产生很多js文件，他们之间可能存在依赖关系
- 如果依赖关系没理清楚，那么会发生各种变量函数未定义的错误
- 普通方式引入
    + 需要我们理清所有js之间的依赖关系，然后使用script按照顺序引入
    + 时间久了之后我们就会忘记这些文件的依赖
    + 而且一个项目如果由多人维护，我们很难理清楚每个js的依赖关系
- RequireJS方式引入
    + 在开发的时候显性的定义每个js模块的依赖，以后随时可以查看
    + 无需理清每个js的依赖与加载顺序，交由RequireJS自动去分析加载

#### 异步加载模块更快

#### 不会产生任何全局变量

## require.config
- 这是一个用于配置requirejs的方法，主要配置模块的加载地址与模块依赖
```javascript
require.config({

	// 配置所有模块的基础路径，这个基础路径自身相对于引入了requirejs的html文件路径
	baseUrl: 'js/',

	// 给模块起名字，以后在define定义模块依赖或者require的时候，直接使用别名即可
	paths: {

		// key是模块的名字，value是模块的地址，该地址是基于baseUrl的
		模块名1: 模块地址1,
		模块名2: 模块地址2
	},

	// 配置普通模块的依赖与输出
	// 值为一个对象，其中key是模块的名字，value是可配置项
	shim: {

		模块名1: {

			// 配置该模块中申明的全局变量，最终变量的值会输出给require。
			exports: 'Bird'，

			// 配置该模块的依赖
			deps: ['模块1'， '模块2']
		},

		模块名2：{}
	}
});
```


## 其他

#### 规范模块的定义
- 一般情况下我们书写的模块都会采用一个自调函数包裹起来，然后暴漏一个全局变量供外界使用。
```javascript
(function(global) {
	var util = {};
	global.util = util;
})(this);
```
- RequireJS提供了独有的API定义与加载模块，采用这种方式定义模块不会存在任何全局变量。
```javascript
define([], function() {
	var util = {};
	return util;
});
```

#### 按需加载
- 可以在需要的时候动态加载js
```javascript
define(['jquery'], function($) {
	$('#btn').on('click', function() {
		require('confirm.js');
	});
});
```

#### 小结
- 其独特的模块定义方式可以在脚本层面申明模块的依赖。
- 其独特的模块定义方式可显著减少全局变量污染。
- 通过js的方式异步加载文件相比script可避免页面堵塞。
- 既可以加载AMD模块，也可以加载普通模块