# 二进制

## 正负表示与计算
负数在运算时会先转换成补码运算，然后运算结果如果首位为1，再次补码转换，求出结果

#### 原码
- 二进制定点表示法，即`最高位`为符合位，`0`表示`正`，`1`表示`负`，`其余位`表示数的`大小`
- 正数15二进制表示：00001111
- 负数-15二进制表示：10001111

#### 反码
- `正数`的反码与原码`相同`
- `负数`的反码是原码`逐位取反`，符号为除外
- 正数15反码表示：00001111
- 负数-15反码表示：11110000

#### 补码
- `正数`的补码与原码`相同`
- `负数`的补码是反码基础上`末位加1`
- 正数15补码表示：00001111
- 负数-15补码表示：11110001

#### 特性
- 二进制数据`补码`后，`再次补码`即可`还原`

#### 数值计算
- 负数先`补码`，然后参与`运算`
- 运算结果再次`补码`，得到运算`结果`

###### 结果为零情况
```
-15 + 15 
二进制 => 10001111 + 00001111
反码   => 11110000 + 00001111
补码   => 11110001 + 00001111
相加   => 00000000
反码   => 11111111
补码   => 00000000
```

###### 结果不为零情况
```
-31 + 15 
二进制 => 10011111 + 00001111
反码   => 11100000 + 00001111
补码   => 11100001 + 00001111
相加   => 11110000
反码   => 10001111
补码   => 10010000
```

## 编码转换

#### 补码求原码

###### 规律法
- 两次补码运算即可还原数据
- 补码运算：先反码，再加1

```
11101110
反码 => 10010001
加一 => 10010010
```

###### 倒推法
- 原码先反码，再加1就是补码
- 那么补码减1，再反码，就倒推得出原码

```
11101110
减一 => 11101101
反码 => 10010010
```

#### 原码求补码

###### 规则法
- 补码运算：先反码，再加1

```
10010010
反码 => 11101101
加一 => 11101110
```

###### 倒推法
- 补码先反码，再加1就是原码
- 那么原码先减1，再反码，就倒推得出补码

```
10010010
减一 => 10010001
反码 => 11101110
```

#### 规律总结
- 原码与补码转换有两种方式
- 1. 反码加一
- 2. 减一反码

## 反码补码加密
- 二进制按照负数的规则反码补码后，再次反码补码即可还原
- 那么可以自己制定反码补码规则，达到加密效果，比如全部位都参与运算

#### 负数加密解密
```
-127
二进制    => 11111111 
全部补码  => 00000001
再补码    => 11111111
最终结果  => -127
```

#### 正数加密解密
```
15
二进制   => 00001111
全部补码 => 11110001
再补码   => 00001111
最终结果 => 15
```

## 小数表示与计算
- 首位代表符号位，0正1负
- 8位代表指数位，0代表0，255代表无穷大，1~254代表指数，可以表示-126~127次方
- 23位代表尾数位

## 位运算
一般的编程语言都含有下面几种位运算符

#### <<左移位
- 二进制数的每一位向左移动n位
- 末尾补0

```
10 << 2
二进制  => 00001010
向移2位 => 00101000
十进制  => 40
```

###### 数值运算规律
- 每一位上的数字会变大2^n幂；整个数值也放大了2^n幂

```
7 << 3
= 7 * 2^3
= 7 * 8
= 56
```

###### 乘法高率运算
- 采用高效率的方式计算7 * 8
- 通常二进制移位是最有效率的，不过对于动态解释性语言可能并不是

```
7 << 3    // 56
```

#### >>右移位
- 二进制数的每一位向右移动n位
- 首位遇1补1，遇0补0

```
10 >> 2
二进制  => 00001010
右移2位 => 00000010
十进制  => 2

-12 >> 2
二进制  => 10001100
补码    => 11110100
右移2位 => 11111101
补码    => 10000011
十进制  => -3

-10 >> 2
二进制  => 10001010
补码    => 11110110
右移2位 => 11111101
补码    => 10000011
十进制  => -3
```

###### 数值运算规律
- 每一位上的数字缩小2^n；整个数值也缩小了2^n幂
- 如果有位移出边界时，那么该数值归0；也就是计算得到的小数被忽略

```
7 >> 1
= 7 / 2^1
= 7 / 2
= 3.5
= 3

7 >> 3
= 7 / 2^3
= 7 / 8
= 0.875
= 0
```

#### >>>右移位
- 和>>运算符一样右移位
- 区别在于首位无论正负(1或0)，都只补0，意味着结果永远为正数

```
-1 >> 31
= 1000...0001 >> 31
= 0000...0001
= 1
```

#### &于
- 有零得零，无零得一

```
10 & 11
二进制 => 00001010 & 00001011
于运算 => 00001010
十进制 => 10
```

#### |或
- 有一得一，无一得零

```
10 | 11
二进制 => 00001010 | 00001011
或运算 => 00001011
十进制 => 11
```

#### ~按位取反
- 逐位取反(包括首位)得出补码，然后通过补码求原码

```
~10
二进制 => 00001010
按位取反 => 11110101
补码 => 10001011
十进制 => -11
```

#### ^异或
- 有一得一，一一得零

```
10 ^ 11
二进制 => 00001010 ^ 00001011
异或运算 => 00000001
十进制 => 1
```

###### ^异或特点
- 两次^异或运算可以还原一个数

```
10 ^ 11
二进制 => 00001010 ^ 00001011
异或运算 => 00000001
十进制 => 1

1 ^ 11
二进制 => 00000001 ^ 00001011
异或运算 => 00001010
十进制 => 10
```

###### 两个变量不用第三个变量交换值
- 两个变量先做异或运算a^b，并用一个变量保存运算结果，假设用a保存
- 然后用结果a再次与保留的变量b异或运算，即找回丢失的变量值a，把这个值赋值给b，完成一般交换
- 然后用结果a再次与新保留的变量a值异或运算，即找回丢失的变量b，把这个值赋值给a，完成全部交换

```
int a = 10, b = 20;
a = a ^ b;  
b = a ^ b;  // 相当于a ^ b ^ b，得a
a = a ^ b;  // 相当于a ^ b ^ a，得b
```
