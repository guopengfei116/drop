# 简介
程序设计 = 数据结构 + 算法

## 数据结构
在`非数值`计算的`程序设计`中，操作`对象`以及他们之间的`关系和操作`
- 逻辑结构
- 物理结构

###  逻辑结构
数据对象中的`数据元素`之间的一种或多种`相互关系`，程序设计中主要的研究对象
- 集合结构
- 线性结构
- 树形结构
- 图形结构

##### 集合结构
`集合结构`中的数据元素只是同属于一个集合，元素之间`没有关系`

##### 线性结构
`线性结构`中的数据元素是`一对一`的关系

##### 树形结构
`树形结构`中的数据元素存在`一对多`的层次关系

##### 图形结构
`图形结构`中的数据元素是`多对多`的关系

### 物理结构
`数据元素`之间的逻辑结构在计算中的`存储形式`，主要研究如何把数据元素存储到`内存`当中
- 顺序存储
- 链式存储

##### 顺序存储
数据元素存放在`地址连续`的存储单元里，其数据间的`逻辑关系`和`物理关系`是`一致`的
- 数组

##### 链式存储
数据元素存放在`任意的`存储单元里，存储单元可以`连续`也可以`不连续`，每个存储单元要用`指针`存储下一个存储单元的`地址`，这种数据结构`不能反映`逻辑关系

##### 索引存储
数据元素存放在`任意的`存储单元里，每个存储单元都分配一个`索引值`，然后根据索引取值，这种数据结构可以反映`一对一`的逻辑关系

##### 散列存储

### 数据类型
是指一组性质相同的值的集合及定义在此集合上的一些操作的总称
- 原子类型
- 结构类型

##### 原子类型
指不可再分解的类型，比如整型，浮点型，字符型等，都是基本数据类型

##### 结构类型
由若干个类型组合而成，可被分解，都是引用数据类型

### 抽象数据类型
是指一个`数学模型`及定义在该模型上的`一组操作`
- 英文：Abstract Data Type，简称ADT
- 根据数据类型的逻辑特性，可以定义出不同的抽象数据类型

##### 抽象
抽取事物具有的普遍本质，是对具体事物的概括
<br/>
抽象是一种思考问题的方式，它隐藏了繁杂的细节，转而关注问题的本质

## 算法
解决特定问题`求解步骤`的描述，在计算机中表示为`指令`的`有限序列`，并且每条指令表示一个或多个操作

#### 特征
- 输入
    + 算法具有`零个`或`多个`输入
- 输出
    + 算法`至少`要有`一个`输出
- 有穷性
    + 算法的执行步骤是`有限次数`的，并且每一步都在可接受的`时间内`完成
- 确定性
    + 算法的每一步都具有`确定的含义`，每一步都被精确定义而`无歧义`，`相同输入`只有`唯一输出`
- 可行性
    + 算法的每一步在`当前环境`下都能够`通过执行`

#### 设计原则
- 算法并`不唯一`，同`一个问题`可以有`多种算法`解决，变幻无穷
- 必须保证`正确性`
- 要具有`可读性`
- 要具有`健壮性`
- `时间效率`尽量`高`，`空间占用`尽量`小`

## 算法效率

#### 影响因素
影响效率主要有如下4种情况，但是如果只关注`算法自身`，抛开其他因素，一个程序的运行时间依赖与`算法策略`的好坏与问题的`输入规模`，
- 算法策略
- 输入规模
- 代码编译后的质量
- 计算机运算速度

#### 度量方案
- 事后统计
    +依据算法设计对应的`测试程序`，记录程序的`运行时间`，从而确定算法效率的高低
- 事前估算
    + 依据`统计方法`对算法进行`估算`

## 算法效率度量
通常我们会采用`事前估算`的方式研究算法，并侧重研究算法随着`输入规模`扩大增长量的一个`抽象`

### 度量原则
一般`不会精确`计算指令执行`多少次`，因为这样还要考虑`编译器优化`之后代码的执行问题
<br/>
对于算法里的`变量声明，循环索引递增与终止条件`等操作，随着输入规模的增长它们对效率的影响逐渐微乎其微，所以`忽略不计`
<br/>
事前估算通常会使用`函数`来描述算法的效率，如果输入规模足够大，函数中的`常数`、甚至`次要项`对函数趋势图像的影响可以逐渐`忽略`，所以我们只需`关注`主项的阶数(`最高次项阶数`)即可

### 时间复杂度计算
主要估算随`问题规模`的变化程序的`执行次数`，然后确定执行的`数量级`，时间复杂度其实就是执行次数复杂度

#### 大O阶公式
- 通常记作 `T(n) = O( f(n) )`，n为问题规模，f(n)为语句关于n执行次数的函数, T(n)称作`渐进时间复杂度`
- 表示随问题规模n的`增大`，算法`执行时间`的增长率与f(n)的`增长率相同`
- 通常，随着n的增长，T(n)增长最慢的算法为`最优算法`

#### 大O阶推导
- 用常数1取代运行时间中的所有加法常数
- 在修改后的运行次数函数中，只保留最高阶项
- 如果最高阶项存在并且不为1，那么去除该项的系数

###### 常数阶
- 即可以用常数表示算法的执行次数，大O阶时间复杂度为`O(1)`
- 例：1 + 1 + 3

###### 线性阶
- 通常是一层循环结构，随问题规模n的增大线性增长，大O阶时间复杂度为`O(n)`
- 例：2n + 3

###### 平方阶
- 通常是两层循环结构，随问题规模n的增大指数增长，大O阶时间复杂度为`O(n^2)`
- 例：n(n + 1) / 2

###### 对数阶
- 通常是一层优化过的循环结构，随问题规模n的增大对数增长，大O阶时间复杂度为`O(logn)`
- 例：3log(2)n + 3

###### nlogn阶
- 通常是两层优化过的循环结构，随问题规模n的增大对数增长，大O阶时间复杂度为`O(nlogn)`
- 例：3nlog(2)n + 3

###### 指数阶
- 通常是n层循环结构，随问题规模n的增大指数增长，大O阶时间复杂度为`O(2^n)`
- 例：2 ^ n

#### 复杂度大小
> O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3)< O(2^n) < O(n!) < O(n^n)

### 空间复杂度计算
主要评估程序运行时所需的存储`空间大小`，在算法优化时我们可以用`空间换取时间`

#### 大O阶公式
- 通常记作 `S(n) = O( f(n) )`，n为问题规模，f(n)为语句关于n所占存储空间的函数
- 表示随问题规模n的`增大`，算法`占用空间`的增长率与f(n)的`增长率相同`
- 通常，随着n的增长，S(n)增长最慢的算法为`最优算法`

### 最坏情况与平均情况
上面关于复杂度的计算得到的都是最坏运行时间，是算法最坏的保障
有时候我们也会评估算法在不同输入时的平均运行时间，这是我们期望的运行时间
